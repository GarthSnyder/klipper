#!/usr/bin/env python3
#
# Preprocessing script for circle packing coordinates from the Packomania
# project at http://hydra.nat.uni-magdeburg.de/packing. This data is used to
# implement the BED_MESH_TILT command. Source data files can be found at:
#
# http://hydra.nat.uni-magdeburg.de/packing/csq/txt/csq_coords.tar.gz
# http://hydra.nat.uni-magdeburg.de/packing/cci/txt/cci_coords.tar.gz
#
# Unpack the input files into a single directory.
#
# This script is NOT run as part of normal Klipper operation. It's used only to
# create extras/tilt_points.py. Note that this is a Python3 script and that it
# requires several packages not included in the standard Klipper installation.
#
# The script normalizes coordinates from -1 to 1, rounds to 4 decimal places,
# and arranges paths in an efficient order. Simple TSP implementation is
# adapted from:
#
# ericphanson.com/blog/2016/the-traveling-salesman-and-10-lines-of-python/
#
# Usage: $0 packomania-directory max-number-of-samples
#
# Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

from sys import argv
from sys import exit
from os import path
import numpy as np
from sklearn.preprocessing import minmax_scale
import random
import math
from scipy.spatial.distance import cdist

MIN_POINTS = 3

if len(argv) != 3:
    exit(f"Usage: {argv[0]} directory N")
dir, n = argv[1], int(argv[2])

def tsp(points, path_start):
    rpoints = minmax_scale(points, feature_range=(0, 100))
    count = len(points)
    # Put point closest to start coordinate first
    first_dist = cdist([path_start], rpoints)
    first_point = min(range(count), key=lambda i: first_dist[0][i])
    rpoints[0], rpoints[first_point] = rpoints[first_point], rpoints[0]
    distances = cdist(rpoints, rpoints)
    tour = [0]
    tour.extend(random.sample(range(1, count), count - 1))
    for temperature in np.logspace(0, 5, num=100000)[::-1]:
        i, j = sorted(random.sample(range(1, count), 2))
        def scoreTour(t):
            indexes = [j, j-1, i, i-1]
            return sum([distances[t[k % count], t[(k + 1) % count]]
                for k in indexes])
        newTour = tour[:i] + tour[j:j+1] + tour[i+1:j] \
            + tour[i:i+1] + tour[j+1:]
        delta = (scoreTour(tour) - scoreTour(newTour)) / temperature
        if math.exp(delta) > random.random():
            tour = newTour.copy()
    tourCost = sum([distances[tour[i]][tour[i+1]] for i in range(count - 1)])
    return (tourCost, np.array([points[m] for m in tour]))

def read_points(filename):
    fullpath = path.join(dir, filename)
    with open(fullpath, "r") as f:
        coord_strings = [line.split()[1:] for line in f.readlines()]
        points = np.array([[float(x) for x in pair] for pair in coord_strings])
        return points

def chunks(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

def print_series(name, filename, normalize, path_start):
    print(f"{name} = [")
    for i in range(MIN_POINTS, n+1):
        points = read_points(filename % i)
        points *= normalize(points)
        _, points = tsp(points, path_start)
        print_points(points)
    print("]")

def print_points(points):
    pt_lines = [", ".join(["[%.4f, %.4f]" % tuple(point) \
        for point in batch]) for batch in chunks(points, 3)]
    print(f"    # Path for {len(points)} points")
    nl= ",\n        "
    print(f"    [{nl.join(pt_lines)}],")

def rect_normalize(points):
    # Scale both axes equivalently
    return 1.0 / max(abs(points.min()), abs(points.max()))

def polar_normalize(points):
    # Convert to polar coordinates and normalize to r = 1
    x, y = points[:,0], points[:,1]
    return 1.0 / np.sqrt(x ** 2 + y ** 2).max()

print(
"""# Probe points for BED_MESH_TILT
#
# Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# DO NOT EDIT THIS FILE! It is generated by scripts/calc_tilt_points.py
# based on data from Packomania, www.packomania.com. If changes are
# necessary, edit the script and regenerate this file.
#
# Garth Snyder <garth@garthsnyder.com> March, 2020
""")
print(f"MIN_POINTS = {MIN_POINTS}\n")

print_series("RECTANGULAR", "csq%d.txt", rect_normalize, [0, 0])
print("")
print_series("CIRCULAR", "cci%d.txt", polar_normalize, [50, 50])
